# -*- coding:utf-8 -*-
# @Time   : 2020/1/2 11:02
# @Author : Dg
# python可变类型与不可变类型
# 不可变类型： 当一个变量引用一个不可变的对象时， 此对象如果添加其他引用，那么该对象的内存地址不发生变化。 引用该对像的变量完全相等。
# 可变类型： 当一个变量指向一个可变对象时，定义每一个可变对象都会有自己的内存地址及空间。
# 当变量的值发生改变后，如果指向的内存地址发生了改变那么该变量引用的对象就是不可变对象（整型，字符串，元祖），反之则是可变对象。（列表，字典，集合）

# 集合我们常用来进行去重和关系运算，集合是无序的。

# python 小整数对象 -5 ~ 256 之间目的是节省开辟空间的时间，优化程序执行的效率。


import sys


def hha():
    return


a = hha()
print(sys.getrefcount(a))

引用计数为主，分代收集为辅
引用计数就是当一个对象的被引用的数值为0是就会将该对象的内存空间释放
但是可能存在循环引用的情况，


2、标记-清理
由上面内容我们可以知道，引用计数机制有两个缺点，缺点1还可以勉强让人接受，缺点2如果不解决，肯定会引起内存泄露，为了解决这个问题，引入了标记删除。

我们先来看个实例，从实例中领会标记删除：

a=[1,2]#假设此时a的引用为1
b=[3,4]#假设此时b的引用为1
#循环引用
a.append(b)#b的引用+1=2
b.append(a)//a的引用+1=2

假如现在需要删除a,应该如何回收呢？（注意删除a可以使用del a，这样a这个引用就不存在了，但是它指向的对象，在标记删除后还存在，因为还被b使用者）


c=[5,6]#假设此时c的引用为1
d=[7,8]#假设此时d的引用为1
#循环引用
c.append(d)#c的引用+1=2
d.append(c)#d的引用+1=2

假如现在需要同时删除c、d，应该如何回收呢？
首先我们应该已经知道，不管上面两种情况的哪一个都无法只通过计数来完成回收，因为随便删除一个变量，它的引用只会-1，变成1，还是大于0，不会回收，为了解决这个问题，开始看标记删除来大展神威吧。

puthon标记删除时通过l两个容器来完成的：死亡容器、存活容器。

首先，我们先来分析情况2，删除c、d
删除后，c的引用为1，d的引用为1，根据引用计数，还无法删除

标记删除第一步：对执行删除操作后的每个引用-1，此时c的引用为0，d的引用为0，把他们都放到死亡容器内。把那些引用仍然大于0的放到存活容器内。

标记删除第二步：遍历存活容器，查看是否有的存活容器引用了死亡容器内的对象，如果有就把该对象(注意是对象，比如0x7f94bb602f80，不是对象的引用)从死亡容器内取出，放到存活容器内。
由于c、d都没有对象引用他们了，所以经过这一步骤，他们还是在死亡组。

标记删除第三部：将死亡组所有对象删除。
这样就完成了对从c、d的删除。
同样道理，我们来分析：只删除a的过程：

标记删除第一步：对执行删除（-1）后的每个引用-1，那么a的引用就是0，b的引用为1，将a放到死亡容器，将b放到存活容器。
标记删除第二步：循环存活容器，发现b引用a，复活a：将a放到存活容器内。
标记删除第三步：删除死亡容器内的所有对象。
综上所说，发现对于循环引用，必须将循环引用的双发对象都删除，才可以被回收。

标记-清理就是这么简单，😀。
3、分代收集
经过上面的【标记 - 清理】方法，已经可以保证对垃圾的回收了，但还有一个问题，【标记 - 清理】什么时候执行比较好呢，是对所有对象都同时执行吗？

同时执行很显然不合理，我们知道，存活越久的对象，说明他的引用更持久（好像是个屁话，引用不持久就被删除了），为了更合理的进行【标记 - 删除】，就需要对对象进行分代处理，思路很简单：

1、新创建的对象做为0代
2、每执行一个【标记 - 删除】，存活的对象代数就 + 1
3、代数越高的对象（存活越持久的对象），进行【标记 - 删除】的时间间隔就越长。这个间隔，江湖人称阀值。
是不是很简单呢。

4、三种情况触发垃圾回收
1、调用gc.collect()
2、GC达到阀值时
3、程序退出时
5、小整数对象池与intern机制：这个机理是有的，但是下文的数据有待认证
由于整数使用广泛，为了避免为整数频繁销毁、申请内存空间，引入了小整数对象池。[-5, 257)是提前定义好的，不会销毁，单个字母也是。

那对于其他整数，或者其他字符串的不可变类型，如果存在重复的多个，例如：

a1 = "mark"
a2 = "mark"
a3 = "mark"
a4 = "mark"
....
a1000 = "mark"
如果每次声明都开辟出一段空间，很显然不合理，这个时候python就会使用intern机制，靠引用计数来维护。

总计：


1、小整数[-5，257)：共用对象，常驻内存
2、单个字符：共用对象，常驻内存
3、单个单词等不可变类型，默认开启intern机制，共用对象，引用计数为0时销毁。